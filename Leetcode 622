LEETCODE - 622
Problem ( Design Circular Queue)
SOlution
class MyCircularQueue {
public:
    MyCircularQueue(int k) {
        q.resize(k);
        cnt=0;
        sz=k;
        headIdx=0;
    }
    bool enQueue(int value) {
        if(isFull())return false;
        q[(headIdx+cnt)%sz]=value;
        cnt+=1;
        return true;    
    }
    bool deQueue() {
         if(isEmpty())return false;
        headIdx=(headIdx+1)%sz;
        cnt -=1;
        return true;     
    }
    int Front() {
        if(isEmpty())return -1;
        return q[headIdx];
    }
    int Rear() {
        if(isEmpty())return -1;
        return q[(headIdx+cnt-1)%sz];
    }
    bool isEmpty() {
        return cnt==0;
    }
    bool isFull() {
        return cnt==sz;
    }
    private:
    int cnt,sz,headIdx;
    vector<int>q;
};

ðŸš€ LeetCode 622 - Design Circular Queue
ðŸ”¹ Problem Statement:
Implement a circular queue with the following operations:

enQueue(int value) â†’ Insert an element if the queue is not full.
deQueue() â†’ Remove an element if the queue is not empty.
Front() â†’ Get the front element of the queue.
Rear() â†’ Get the last element of the queue.
isEmpty() â†’ Check if the queue is empty.
isFull() â†’ Check if the queue is full.
ðŸ”¹ Approach:
âœ… Use a fixed-size array to store elements.
âœ… Maintain headIdx, cnt, and sz to track the queueâ€™s state.
âœ… Modulo operation (%) is used for circular indexing.
âœ… Efficient operations with O(1) time complexity for enqueue, dequeue, and retrieval.

ðŸ”¹ Complexity Analysis:
Time Complexity: O(1) for all operations.
Space Complexity: O(k), where k is the queue size.
